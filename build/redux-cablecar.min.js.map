{"version":3,"sources":["webpack:///redux-cablecar.min.js","webpack:///webpack/bootstrap 45b4500ef74132202776","webpack:///./index.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./src/cableCarDispatcher.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_middleware","_middleware2","middleware","_cableCar","_cableCar2","_cableCarDispatcher","_cableCarDispatcher2","cableProvider","dispatcher","CableCarDispatcher","store","next","incomingAction","action","car","type","destroyCar","CableCarChannel","getState","reset","changeCar","previousChannel","newChannel","options","channel","getCar","getDefaultCar","allows","CableCar__Action","running","send","optimistic","console","error","optimisticOnFail","connect","e","Error","CableCar","addCar","changeChannel","bind","disconnect","getChannel","getParams","perform","unsubscribe","setProvider","newProvider","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","_this","this","arguments","undefined","initialized","dispatch","connected","disconnected","received","msg","rejected","actionCableProvider","defaultOptions","prefix","initialize","assign","cableParams","params","consumer","createConsumer","wsURL","subscription","subscriptions","create","newAction","matchPrefix","slice","method","payload","provider","lines","addLine","line","clearAllLines","clearLine","getLines","ReferenceError","oldLine","newLine","activeLine","getSingleActiveLine","allLines","activeLines","push","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","context","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","WebSocket","window","logger","url","ref","getConfig","Consumer","createWebSocketURL","name","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","startDebugging","debugging","stopDebugging","log","messages","Date","now","apply","concat","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","interval","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","unsupportedProtocol","indexOf","item","l","Connection","open","monitor","reopenDelay","data","webSocket","JSON","stringify","isActive","uninstallEventHandlers","installEventHandlers","close","arg","allowReconnect","ref1","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","identifier","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","channelName","mixin","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","findAll","len","results","s","args","callbackName","command","extend","object","properties"],"mappings":"AAAAA,OAAOC,QACE,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAH,OAGA,IAAAD,GAAAK,EAAAD,IACAH,WACAK,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAR,EAAAC,QAAAD,IAAAC,QAAAE,GAGAH,EAAAO,QAAA,EAGAP,EAAAC,QAvBA,GAAAI,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDOM,SAAUH,EAAQC,EAASE,GAEhC,YAUA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GARvFG,OAAOC,eAAehB,EAAS,cAC7BiB,OAAO,GElDV,IAAAC,GAAAhB,EAAA,GFuDKiB,EAAeR,EAAuBO,EAI1ClB,GAAQc,QEzDMM,WF6DT,SAAUrB,EAAQC,EAASE,GAEhC,YAcA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAZvFG,OAAOC,eAAehB,EAAS,cAC7BiB,OAAO,GGpEV,IAAAI,GAAAnB,EAAA,GHyEKoB,EAAaX,EAAuBU,GGxEzCE,EAAArB,EAAA,GH4EKsB,EAAuBb,EAAuBY,GG1E/CE,SAEEC,EAAa,GAAIC,WAEjBP,EAAa,SAAAQ,GAAA,MAAS,UAAAC,GAAA,MAAQ,UAACC,GACnC,GAAMC,GAASD,EACXE,QAEJ,QAAQD,EAAOE,MAEb,IAAK,uBACL,IAAK,qBACL,IAAK,wBACH,MAAOJ,GAAKE,EAEd,KAAK,mBAEH,MADAL,GAAWQ,WAAWH,EAAOI,iBACtBP,EAAMQ,UAEf,KAAK,uBAEH,MADAV,GAAWW,QACJT,EAAMQ,UAEf,KAAK,0BAEH,MADAV,GAAWY,UAAUP,EAAOQ,gBAAiBR,EAAOS,WAAYT,EAAOU,SAChEb,EAAMQ,UAEf,SAEE,MADAJ,GAAMD,EAAOW,QAAUhB,EAAWiB,OAAOZ,EAAOW,SAAWhB,EAAWkB,gBAClEZ,GAAOA,EAAIa,OAAOd,KAAYA,EAAOe,iBACnCd,EAAIe,SACNf,EAAIgB,KAAKjB,GASJA,EAAOkB,WAAapB,EAAKE,GAAUH,EAAMQ,aAP9Cc,QAAQC,MAAM,4BACZ,iEACApB,EACA,qBAAuBC,EAAIS,QAAQW,kBAE9BpB,EAAIS,QAAQW,iBAAmBvB,EAAKE,GAAUH,EAAMQ,YAItDP,EAAKE,MAKpBX,GAAWiC,QAAU,SAACzB,EAAOc,EAASD,GACpC,IAAKhB,EACH,IACEA,EAAgBvB,EAAQ,GACxB,MAAMoD,GACN,KAAM,IAAIC,OAAJ,uFAAiGD,GAI3G,GAAItB,GAAM,GAAIwB,WAAS/B,EAAeG,EAAOc,EAASD,EAItD,OAHAf,GAAW+B,OAAOf,EAASV,IAIzB0B,cAAe1B,EAAI0B,cAAcC,KAAK3B,GACtC4B,WAAY5B,EAAI4B,WAAWD,KAAK3B,GAChC6B,WAAY7B,EAAI6B,WAAWF,KAAK3B,GAChC8B,UAAW9B,EAAI8B,UAAUH,KAAK3B,GAC9B+B,QAAS/B,EAAI+B,QAAQJ,KAAK3B,GAC1BgB,KAAMhB,EAAIgB,KAAKW,KAAK3B,GACpBgC,YAAahC,EAAIgC,YAAYL,KAAK3B,KAItCZ,EAAW6C,YAAc,SAACC,GACxBzC,EAAgByC,GHiFjBlE,EAAQc,QG9EMM,GHkFT,SAAUrB,EAAQC,GAEvB,YAUA,SAASmE,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCARhHvD,OAAOC,eAAehB,EAAS,cAC7BiB,OAAO,GAGT,IAAIsD,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAU7D,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAX4D,SAAyB5D,EAAI8D,cAAgBF,QAAU5D,IAAQ4D,OAAOG,UAAY,eAAkB/D,IAElQgE,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMtE,OAAOC,eAAe8D,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUb,EAAakB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBR,EAAYM,UAAWY,GAAiBC,GAAaX,EAAiBR,EAAamB,GAAqBnB,MIzK5gBb,EJ6KL,WI3Kd,QAAAA,GAAY/B,EAAeG,EAAOc,GAAuB,GAAA+C,GAAAC,KAAdjD,EAAckD,UAAAV,OAAA,GAAAW,SAAAD,UAAA,GAAAA,UAAA,KACvD,IADuDxB,EAAAuB,KAAAlC,GAAAkC,KA0CzDG,YAAc,iBAAMJ,GAAKK,UAAW7D,KAAM,0BA1CeyD,KA4CzDK,UAAY,WACVN,EAAKK,UAAW7D,KAAM,uBACtBwD,EAAK1C,SAAU,EACX0C,EAAKhD,QAAQsD,WAAaN,EAAKhD,QAAQsD,UAAUxF,QA/CEmF,KAkDzDM,aAAe,WACbP,EAAKK,UAAW7D,KAAM,0BACtBwD,EAAK1C,SAAU,EACX0C,EAAKhD,QAAQuD,cAAgBP,EAAKhD,QAAQuD,aAAazF,QArDJmF,KAwDzDO,SAAW,SAACC,GACVT,EAAKK,SAASI,IAzDyCR,KA4DzDS,SAAW,WACT,KAAM,IAAI5C,OAAJ,+DAEQkC,EAAK/C,QAFb,MA5DuB,mBAAlBjB,GACT,KAAM,IAAI8B,OAAJ,2CAAqD9B,EAG7D,IAAqB,mBAAVG,IAAmD,mBAAnBA,GAAMkE,SAC/C,KAAM,IAAIvC,OAAJ,4BAAsC3B,EAG9C,IAAuB,gBAAZc,GACT,KAAM,IAAIa,OAAJ,8BAAwCb,EAGhDgD,MAAKU,oBAAsB3E,EAC3BiE,KAAK9D,MAAQA,CAEb,IAAMyE,IAAmBC,OAAQ,QAASlD,kBAAkB,EAC5DsC,MAAKa,WAAW7D,EAAS3B,OAAOyF,OAAOH,EAAgB5D,IJkTxD,MAjGAmC,GAAapB,IACX8B,IAAK,aACLrE,MAAO,SIhNCyB,EAASD,GAElBiD,KAAKhD,QAAUA,EACfgD,KAAKjD,QAAUA,EACfiD,KAAK3C,SAAU,CAEf,IAAI0D,GAAchE,EAAQiE,UAC1BD,GAAc1F,OAAOyF,QAAS9D,WAAW+D,GAEzCf,KAAKiB,SAAWjB,KAAKU,oBAAoBQ,eAAenE,EAAQoE,OAChEnB,KAAKoB,aAAepB,KAAKiB,SAASI,cAAcC,OAC9CP,GACEZ,YAAaH,KAAKG,YAClBE,UAAWL,KAAKK,UAChBC,aAAcN,KAAKM,aACnBC,SAAUP,KAAKO,SACfE,SAAUT,KAAKS,cJsNlBb,IAAK,WAILrE,MAAO,SI1LDc,GACP,GAAMkF,GAAYlG,OAAOyF,OAAOzE,GAC9BW,QAASgD,KAAKhD,QACdI,kBAAkB,GAEpB4C,MAAK9D,MAAMkE,SAASmB,MJ6LnB3B,IAAK,SACLrE,MAAO,SI3LHc,GACL,GAAsB,YAAlB,mBAAOA,GAAP,YAAAwC,EAAOxC,KAA8C,gBAAhBA,GAAOE,KAC9C,KAAM,IAAIsB,OAAJ,aAAuBxB,EAAvB,+CAGR,OAAO2D,MAAKwB,YAAYnF,EAAOE,SJ8L9BqD,IAAK,cACLrE,MAAO,SI5LEgB,GACV,GAAMqE,GAASrE,EAAKkF,MAAM,EAAGzB,KAAKjD,QAAQ6D,OAAOrB,OACjD,OAAOqB,KAAWZ,KAAKjD,QAAQ6D,UJkM9BhB,IAAK,aACLrE,MAAO,WI9LRyE,KAAKiB,SAAS/C,gBJqMb0B,IAAK,gBACLrE,MAAO,SIlMIyB,GAAuB,GAAdD,GAAckD,UAAAV,OAAA,GAAAW,SAAAD,UAAA,GAAAA,UAAA,KACnCD,MAAK1B,cACL0B,KAAKa,WAAW7D,EAAS3B,OAAOyF,OAAOd,KAAKjD,QAASA,OJuMpD6C,IAAK,aACLrE,MAAO,WIpMR,MAAOyE,MAAKhD,WJwMX4C,IAAK,YACLrE,MAAO,WIrMR,MAAOyE,MAAKjD,QAAQiE,UJyMnBpB,IAAK,UACLrE,MAAO,SIvMFmG,EAAQC,GACd3B,KAAKoB,aAAa/C,QAAQqD,EAAQC,MJ0MjC/B,IAAK,OACLrE,MAAO,SIxMLc,GACH2D,KAAKoB,aAAa9D,KAAKjB,MJ2MtBuD,IAAK,cACLrE,MAAO,WIxMRyE,KAAKoB,aAAa9C,cAClB0B,KAAKM,mBJ6MCxC,IAGTxD,GAAQc,QIxUY0C,GJ4Uf,SAAUzD,EAAQC,GAEvB,YAQA,SAASmE,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHvD,OAAOC,eAAehB,EAAS,cAC7BiB,OAAO,GAGT,IAAI2D,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMtE,OAAOC,eAAe8D,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUb,EAAakB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBR,EAAYM,UAAWY,GAAiBC,GAAaX,EAAiBR,EAAamB,GAAqBnB,MKpV5gB1C,ELwVK,WKtVxB,QAAAA,GAAY2F,GAAUnD,EAAAuB,KAAA/D,EACpB,IAAI4F,KAEJ7B,MAAK8B,QAAU,SAACC,EAAMzF,GAAUuF,EAAME,GAAQzF,GAC9C0D,KAAKgC,cAAgB,WAAQH,MAC7B7B,KAAKiC,UAAY,SAACF,GAAWF,EAAME,GAAQ7B,QAC3CF,KAAKkC,SAAW,iBAAML,ILmbvB,MA/EA3C,GAAajD,IACX2D,IAAK,SACLrE,MAAO,SKnWHwG,EAAMzF,GACX,GAAI0D,KAAK/C,OAAO8E,GACd,KAAM,IAAII,gBACR,sEAAwEJ,EAI5E,OADA/B,MAAK8B,QAAQC,EAAMzF,GACZA,KLoWNsD,IAAK,YACLrE,MAAO,SKlWA6G,EAASC,EAAStF,GAC1B,GAAIT,GAAM0D,KAAK/C,OAAOmF,EAEtB,OAAK9F,GAODA,EAAI0B,eACN1B,EAAI0B,cAAcqE,EAAStF,GAC3BiD,KAAKiC,UAAUG,GACfpC,KAAK8B,QAAQO,EAAS/F,GACfA,IAEPkB,QAAQC,MAAM,GAAI0E,gBAChB,0EACC7F,IACI,IAfPkB,QAAQC,MAAM,GAAI0E,gBAChB,sEAAwEC,KAEnE,ML8WRxC,IAAK,aACLrE,MAAO,SK/VCwG,GACT,GAAIO,GAAaP,GAAQ/B,KAAKuC,qBAE9B,KAAKD,EAIH,MAHA9E,SAAQC,MAAM,GAAI0E,gBAChB,uEAAyEJ,KAEpE,CAGT,IAAIzF,GAAM0D,KAAK/C,OAAOqF,EACtB,OAAIhG,IAAOA,EAAIgC,aACbhC,EAAIgC,cACJ0B,KAAKiC,UAAUK,GACRhG,IAEPkB,QAAQC,MAAM,GAAI0E,gBAChB,yEACC7F,IACI,ML+VRsD,IAAK,SACLrE,MAAO,SK5VHwG,GACL,MAAO/B,MAAKkC,WAAWH,ML+VtBnC,IAAK,gBACLrE,MAAO,WK5VR,GAAI+G,GAAatC,KAAKuC,qBACtB,OAAOD,GAAatC,KAAKkC,WAAWI,GAAcpC,ULgWjDN,IAAK,sBACLrE,MAAO,WK7VR,GAAMiH,GAAWxC,KAAKkC,WAClBO,IACJ,KAAK,GAAIV,KAAQS,GACXA,EAAST,IAASU,EAAYC,KAAKX,EAEzC,OAA8B,KAAvBU,EAAYlD,OAAekD,EAAY,GAAKvC,ULmWlDN,IAAK,QACLrE,MAAO,WKhWRyE,KAAKgC,oBLqWC/F,IAGT3B,GAAQc,QK9bYa,GLkcf,SAAU5B,EAAQC,EAASE,GMncjC,GAAAmI,GAAAC,GAAA,WACA,GAAAC,GAAA7C,MAEA,YACA,WACA,GAAAyB,WAEAzB,MAAA8C,aACAC,UACAC,eACAC,QAAA,UACAC,KAAA,OACAC,aAAA,uBACAC,UAAA,uBAEAC,mBAAA,SACAC,WAAA,kDAEAC,UAAAC,OAAAD,UACAE,OAAAD,OAAAhG,QACA0D,eAAA,SAAAwC,GACA,GAAAC,EAIA,OAHA,OAAAD,IACAA,EAAA,OAAAC,EAAA3D,KAAA4D,UAAA,QAAAD,EAAA3D,KAAA+C,SAAAM,oBAEA,GAAAP,GAAAe,SAAA7D,KAAA8D,mBAAAJ,KAEAE,UAAA,SAAAG,GACA,GAAAC,EAEA,OADAA,GAAAC,SAAAC,KAAAC,cAAA,2BAAAJ,EAAA,MACA,MAAAC,IAAAI,aAAA,mBAEAN,mBAAA,SAAAJ,GACA,GAAAW,EACA,OAAAX,KAAA,UAAAY,KAAAZ,IACAW,EAAAJ,SAAAM,cAAA,KACAF,EAAAG,KAAAd,EACAW,EAAAG,KAAAH,EAAAG,KACAH,EAAAI,SAAAJ,EAAAI,SAAAC,QAAA,aACAL,EAAAG,MAEAd,GAGAiB,eAAA,WACA,MAAA3E,MAAA4E,WAAA,GAEAC,cAAA,WACA,MAAA7E,MAAA4E,UAAA,MAEAE,IAAA,WACA,GAAAC,GAAApB,CAEA,IADAoB,EAAA,GAAA9E,UAAAV,OAAAkC,EAAA5G,KAAAoF,UAAA,MACAD,KAAA4E,UAEA,MADAG,GAAArC,KAAAsC,KAAAC,QACAtB,EAAA3D,KAAAyD,QAAAqB,IAAAI,MAAAvB,GAAA,iBAAAwB,OAAA1D,EAAA5G,KAAAkK,SAKKlK,KAAAmF,QACFnF,KAAAgI,EAEH,IAAAC,GAAAD,EAAAC,aAEA,YACA,WACA,GAAA7E,GAAA,SAAAmH,EAAAC,GAAkC,kBAAmB,MAAAD,GAAAF,MAAAG,EAAApF,YAErD6C,GAAAwC,kBAAA,WAUA,QAAAA,GAAAC,GACAvF,KAAAuF,aACAvF,KAAAwF,oBAAAvH,EAAA+B,KAAAwF,oBAAAxF,MACAA,KAAAyF,kBAAA,EAZA,GAAAC,GAAAT,EAAAU,CA8HA,OA5HAL,GAAAM,cACAC,IAAA,EACAC,IAAA,IAGAR,EAAAS,eAAA,EAQAT,EAAArG,UAAA+G,MAAA,WACA,IAAAhG,KAAAiG,YAKA,MAJAjG,MAAAkG,UAAAjB,UACAjF,MAAAmG,UACAnG,KAAAoG,eACAnC,SAAAoC,iBAAA,mBAAArG,KAAAwF,qBACA1C,EAAAgC,IAAA,6CAAA9E,KAAAsG,kBAAA,QAIAhB,EAAArG,UAAAsH,KAAA,WACA,GAAAvG,KAAAiG,YAIA,MAHAjG,MAAAmG,UAAAlB,IACAjF,KAAAwG,cACAvC,SAAAwC,oBAAA,mBAAAzG,KAAAwF,qBACA1C,EAAAgC,IAAA,8BAIAQ,EAAArG,UAAAgH,UAAA,WACA,aAAAjG,KAAAkG,WAAA,MAAAlG,KAAAmG,WAGAb,EAAArG,UAAAyH,WAAA,WACA,MAAA1G,MAAA2G,SAAA1B,KAGAK,EAAArG,UAAA2H,cAAA,WAIA,MAHA5G,MAAAyF,kBAAA,EACAzF,KAAA0G,mBACA1G,MAAA6G,eACA/D,EAAAgC,IAAA,uCAGAQ,EAAArG,UAAA6H,iBAAA,WAEA,MADA9G,MAAA6G,eAAA5B,IACAnC,EAAAgC,IAAA,0CAGAQ,EAAArG,UAAAmH,aAAA,WAEA,MADApG,MAAAwG,cACAxG,KAAA+G,QAGAzB,EAAArG,UAAAuH,YAAA,WACA,MAAAQ,cAAAhH,KAAAiH,cAGA3B,EAAArG,UAAA8H,KAAA,WACA,MAAA/G,MAAAiH,YAAAC,WAAA,SAAAnH,GACA,kBAEA,MADAA,GAAAoH,mBACApH,EAAAgH,SAEW/G,WAAAsG,oBAGXhB,EAAArG,UAAAqH,gBAAA,WACA,GAAAc,GAAAtB,EAAAD,EAAAlC,CAGA,OAFAA,GAAA3D,KAAAhB,YAAA4G,aAAAC,EAAAlC,EAAAkC,IAAAC,EAAAnC,EAAAmC,IACAsB,EAAA,EAAAC,KAAAvC,IAAA9E,KAAAyF,kBAAA,GACA4B,KAAAC,MAAA,IAAA5B,EAAA0B,EAAAvB,EAAAC,KAGAR,EAAArG,UAAAkI,iBAAA,WACA,GAAAnH,KAAAuH,oBAGA,MAFAzE,GAAAgC,IAAA,oEAAA9E,KAAAyF,kBAAA,oBAAAzF,KAAAsG,kBAAA,4BAAAX,EAAA3F,KAAA6G,gBAAA,yBAAA7G,KAAAhB,YAAA+G,eAAA,MACA/F,KAAAyF,oBACAzF,KAAAwH,uBACA1E,EAAAgC,IAAA,2DAEAhC,EAAAgC,IAAA,+BACA9E,KAAAuF,WAAAkC,WAKAnC,EAAArG,UAAAsI,kBAAA,WACA,GAAA5D,EACA,OAAAgC,GAAA,OAAAhC,EAAA3D,KAAA2G,UAAAhD,EAAA3D,KAAAkG,WAAAlG,KAAAhB,YAAA+G,gBAGAT,EAAArG,UAAAuI,qBAAA,WACA,MAAAxH,MAAA6G,gBAAAlB,EAAA3F,KAAA6G,gBAAA7G,KAAAhB,YAAA+G,gBAGAT,EAAArG,UAAAuG,oBAAA,WACA,eAAAvB,SAAAyD,gBACA,MAAAR,YAAA,SAAAnH,GACA,kBACA,GAAAA,EAAAwH,sBAAAxH,EAAAwF,WAAAoC,SAEA,MADA7E,GAAAgC,IAAA,sFAAAb,SAAAyD,iBACA3H,EAAAwF,WAAAkC,WAGazH,MAAA,MAIbiF,EAAA,WACA,UAAAD,OAAA4C,WAGAjC,EAAA,SAAAkC,GACA,OAAA5C,IAAA4C,GAAA,KAGAnC,EAAA,SAAAoC,EAAAjC,EAAAC,GACA,MAAAuB,MAAAvB,IAAAD,EAAAwB,KAAAxB,IAAAC,EAAAgC,KAGAxC,OAIKzK,KAAAmF,MACL,WACA,GAAAV,GAAA0D,EAAAM,EAAAK,EAAAoE,EAAAC,EACAvG,WACAxD,EAAA,SAAAmH,EAAAC,GAAgC,kBAAmB,MAAAD,GAAAF,MAAAG,EAAApF,aACnDgI,cAAA,SAAAC,GAAgD,OAAA5I,GAAA,EAAA6I,EAAAnI,KAAAT,OAAiCD,EAAA6I,EAAO7I,IAAO,GAAAA,IAAAU,YAAAV,KAAA4I,EAAA,MAAA5I,EAA+C,UAE9IqE,GAAAb,EAAAC,SAAAC,EAAAW,EAAAX,cAAAM,EAAAK,EAAAL,UAEAyE,EAAA,GAAAzE,EAAA/D,OAAAkC,EAAA5G,KAAAyI,EAAA,EAAAhE,EAAAgE,EAAA/D,OAAA,IAAAD,EAAA,MAAA0I,EAAA1E,EAAAhE,KAEAwD,EAAAsF,WAAA,WAGA,QAAAA,GAAAnH,GACAjB,KAAAiB,WACAjB,KAAAqI,KAAApK,EAAA+B,KAAAqI,KAAArI,MACAA,KAAAqB,cAAArB,KAAAiB,SAAAI,cACArB,KAAAsI,QAAA,GAAAxF,GAAAwC,kBAAAtF,MACAA,KAAAM,cAAA,EA4JA,MAnKA8H,GAAAG,YAAA,IAUAH,EAAAnJ,UAAA3B,KAAA,SAAAkL,GACA,QAAAxI,KAAA2H,WACA3H,KAAAyI,UAAAnL,KAAAoL,KAAAC,UAAAH,KACA,IAMAJ,EAAAnJ,UAAAoJ,KAAA,WACA,MAAArI,MAAA4I,YACA9F,EAAAgC,IAAA,uDAAA9E,KAAAtD,aACA,IAEAoG,EAAAgC,IAAA,uCAAA9E,KAAAtD,WAAA,mBAAA4G,GACA,MAAAtD,KAAAyI,WACAzI,KAAA6I,yBAEA7I,KAAAyI,UAAA,GAAA3F,GAAAS,UAAAvD,KAAAiB,SAAAyC,IAAAJ,GACAtD,KAAA8I,uBACA9I,KAAAsI,QAAAtC,SACA,IAIAoC,EAAAnJ,UAAA8J,MAAA,SAAAC,GACA,GAAAC,GAAAC,CAOA,IANAD,GAAA,MAAAD,KACAC,gBAAA,IACWA,eACXA,GACAjJ,KAAAsI,QAAA/B,OAEAvG,KAAA4I,WACA,cAAAM,EAAAlJ,KAAAyI,WAAAS,EAAAH,QAAA,QAIAX,EAAAnJ,UAAAwI,OAAA,WACA,GAAAhK,EAEA,IADAqF,EAAAgC,IAAA,yCAAA9E,KAAAtD,aACAsD,KAAA4I,WAWA,MAAA5I,MAAAqI,MAVA,KACA,MAAArI,MAAA+I,QACa,MAAAI,GAEb,MADA1L,GAAA0L,EACArG,EAAAgC,IAAA,6BAAArH,GACa,QACbqF,EAAAgC,IAAA,0BAAA9E,KAAAhB,YAAAuJ,YAAA,MACArB,WAAAlH,KAAAqI,KAAArI,KAAAhB,YAAAuJ,eAOAH,EAAAnJ,UAAAmK,YAAA,WACA,GAAAF,EACA,eAAAA,EAAAlJ,KAAAyI,WAAAS,EAAAzE,SAAA,QAGA2D,EAAAnJ,UAAA0I,OAAA,WACA,MAAA3H,MAAAqJ,QAAA,SAGAjB,EAAAnJ,UAAA2J,SAAA,WACA,MAAA5I,MAAAqJ,QAAA,sBAGAjB,EAAAnJ,UAAAqK,oBAAA,WACA,GAAAJ,EACA,OAAAA,GAAAlJ,KAAAoJ,cAAAnB,EAAApN,KAAAkN,EAAAmB,IAAA,GAGAd,EAAAnJ,UAAAoK,QAAA,WACA,GAAAH,GAAAK,CAEA,OADAA,GAAA,GAAAtJ,UAAAV,OAAAkC,EAAA5G,KAAAoF,UAAA,MACAiJ,EAAAlJ,KAAAtD,WAAAuL,EAAApN,KAAA0O,EAAAL,IAAA,GAGAd,EAAAnJ,UAAAvC,SAAA,WACA,GAAAwM,GAAAM,EAAAjO,CACA,KAAAiO,IAAAjG,WAEA,GADAhI,EAAAgI,UAAAiG,GACAjO,KAAA,OAAA2N,EAAAlJ,KAAAyI,WAAAS,EAAAO,WAAA,QACA,MAAAD,GAAAE,aAGA,cAGAtB,EAAAnJ,UAAA6J,qBAAA,WACA,GAAAa,GAAAC,CACA,KAAAD,IAAA3J,MAAA6J,OACAD,EAAA5J,KAAA6J,OAAAF,GAAA1L,KAAA+B,MACAA,KAAAyI,UAAA,KAAAkB,GAAAC,GAIAxB,EAAAnJ,UAAA4J,uBAAA,WACA,GAAAc,EACA,KAAAA,IAAA3J,MAAA6J,OACA7J,KAAAyI,UAAA,KAAAkB,GAAA,cAIAvB,EAAAnJ,UAAA4K,QACAC,QAAA,SAAAC,GACA,GAAAC,GAAAF,EAAAZ,EAAA3M,CACA,IAAAyD,KAAAsJ,sBAIA,OADAJ,EAAAR,KAAAuB,MAAAF,EAAAvB,MAAAwB,EAAAd,EAAAc,WAAAF,EAAAZ,EAAAY,QAAAvN,EAAA2M,EAAA3M,KACAA,GACA,IAAAyG,GAAAC,QAEA,MADAjD,MAAAsI,QAAA1B,gBACA5G,KAAAqB,cAAA6I,QACA,KAAAlH,GAAAE,KACA,MAAAlD,MAAAsI,QAAA5B,YACA,KAAA1D,GAAAG,aACA,MAAAnD,MAAAqB,cAAA8I,OAAAH,EAAA,YACA,KAAAhH,GAAAI,UACA,MAAApD,MAAAqB,cAAA+I,OAAAJ,EACA,SACA,MAAAhK,MAAAqB,cAAA8I,OAAAH,EAAA,WAAAF,KAGAzB,KAAA,WAGA,GAFAvF,EAAAgC,IAAA,kCAAA9E,KAAAoJ,cAAA,iBACApJ,KAAAM,cAAA,GACAN,KAAAsJ,sBAEA,MADAxG,GAAAgC,IAAA,gEACA9E,KAAA+I,OACAE,gBAAA,KAIAF,MAAA,SAAAgB,GAEA,GADAjH,EAAAgC,IAAA,4BACA9E,KAAAM,aAKA,MAFAN,MAAAM,cAAA,EACAN,KAAAsI,QAAAxB,mBACA9G,KAAAqB,cAAAgJ,UAAA,gBACAC,qBAAAtK,KAAAsI,QAAArC,eAGAxI,MAAA,WACA,MAAAqF,GAAAgC,IAAA,6BAIAsD,MAIKvN,KAAAmF,MACL,WACA,GAAAyB,WAEAqB,GAAAyH,cAAA,WACA,QAAAA,GAAAtJ,GACAjB,KAAAiB,WACAjB,KAAAqB,iBAwHA,MArHAkJ,GAAAtL,UAAAqC,OAAA,SAAAkJ,EAAAC,GACA,GAAAzN,GAAAgE,EAAAI,CAMA,OALApE,GAAAwN,EACAxJ,EAAA,gBAAAhE,MACAA,WAEAoE,EAAA,GAAA0B,GAAA4H,aAAA1K,KAAAiB,SAAAD,EAAAyJ,GACAzK,KAAA2K,IAAAvJ,IAGAmJ,EAAAtL,UAAA0L,IAAA,SAAAvJ,GAKA,MAJApB,MAAAqB,cAAAqB,KAAAtB,GACApB,KAAAiB,SAAA2J,yBACA5K,KAAAmK,OAAA/I,EAAA,eACApB,KAAA6K,YAAAzJ,EAAA,aACAA,GAGAmJ,EAAAtL,UAAA6L,OAAA,SAAA1J,GAKA,MAJApB,MAAA+K,OAAA3J,GACApB,KAAAgL,QAAA5J,EAAA4I,YAAAzK,QACAS,KAAA6K,YAAAzJ,EAAA,eAEAA,GAGAmJ,EAAAtL,UAAAmL,OAAA,SAAAJ,GACA,GAAA1K,GAAA2L,EAAAtH,EAAAuH,EAAA9J,CAGA,KAFAuC,EAAA3D,KAAAgL,QAAAhB,GACAkB,KACA5L,EAAA,EAAA2L,EAAAtH,EAAApE,OAAuCD,EAAA2L,EAAS3L,IAChD8B,EAAAuC,EAAArE,GACAU,KAAA+K,OAAA3J,GACApB,KAAAmK,OAAA/I,EAAA,YACA8J,EAAAxI,KAAAtB,EAEA,OAAA8J,IAGAX,EAAAtL,UAAA8L,OAAA,SAAA3J,GACA,GAAA+J,EAaA,OAZAnL,MAAAqB,cAAA,WACA,GAAA/B,GAAA2L,EAAAtH,EAAAuH,CAGA,KAFAvH,EAAA3D,KAAAqB,cACA6J,KACA5L,EAAA,EAAA2L,EAAAtH,EAAApE,OAAyCD,EAAA2L,EAAS3L,IAClD6L,EAAAxH,EAAArE,GACA6L,IAAA/J,GACA8J,EAAAxI,KAAAyI,EAGA,OAAAD,IACWrQ,KAAAmF,MACXoB,GAGAmJ,EAAAtL,UAAA+L,QAAA,SAAAhB,GACA,GAAA1K,GAAA2L,EAAAtH,EAAAuH,EAAAC,CAGA,KAFAxH,EAAA3D,KAAAqB,cACA6J,KACA5L,EAAA,EAAA2L,EAAAtH,EAAApE,OAAuCD,EAAA2L,EAAS3L,IAChD6L,EAAAxH,EAAArE,GACA6L,EAAAnB,gBACAkB,EAAAxI,KAAAyI,EAGA,OAAAD,IAGAX,EAAAtL,UAAAiL,OAAA,WACA,GAAA5K,GAAA2L,EAAAtH,EAAAuH,EAAA9J,CAGA,KAFAuC,EAAA3D,KAAAqB,cACA6J,KACA5L,EAAA,EAAA2L,EAAAtH,EAAApE,OAAuCD,EAAA2L,EAAS3L,IAChD8B,EAAAuC,EAAArE,GACA4L,EAAAxI,KAAA1C,KAAA6K,YAAAzJ,EAAA,aAEA,OAAA8J,IAGAX,EAAAtL,UAAAoL,UAAA,WACA,GAAAe,GAAAC,EAAA/L,EAAA2L,EAAAtH,EAAAuH,EAAA9J,CAIA,KAHAiK,EAAApL,UAAA,GAAAmL,EAAA,GAAAnL,UAAAV,OAAAkC,EAAA5G,KAAAoF,UAAA,MACA0D,EAAA3D,KAAAqB,cACA6J,KACA5L,EAAA,EAAA2L,EAAAtH,EAAApE,OAAuCD,EAAA2L,EAAS3L,IAChD8B,EAAAuC,EAAArE,GACA4L,EAAAxI,KAAA1C,KAAAmK,OAAAjF,MAAAlF,MAAAoB,EAAAiK,GAAAlG,OAAA1D,EAAA5G,KAAAuQ,KAEA,OAAAF,IAGAX,EAAAtL,UAAAkL,OAAA,WACA,GAAAiB,GAAAC,EAAA/L,EAAA2L,EAAAC,EAAA9J,EAAAC,CAQA,KAPAD,EAAAnB,UAAA,GAAAoL,EAAApL,UAAA,GAAAmL,EAAA,GAAAnL,UAAAV,OAAAkC,EAAA5G,KAAAoF,UAAA,MAEAoB,EADA,gBAAAD,GACApB,KAAAgL,QAAA5J,IAEAA,GAEA8J,KACA5L,EAAA,EAAA2L,EAAA5J,EAAA9B,OAAiDD,EAAA2L,EAAS3L,IAC1D8B,EAAAC,EAAA/B,GACA4L,EAAAxI,KAAA,kBAAAtB,GAAAiK,GAAAjK,EAAAiK,GAAAnG,MAAA9D,EAAAgK,GAAA,OAEA,OAAAF,IAGAX,EAAAtL,UAAA4L,YAAA,SAAAzJ,EAAAkK,GACA,GAAAtB,EAEA,OADAA,GAAA5I,EAAA4I,WACAhK,KAAAiB,SAAA3D,MACAgO,UACAtB,gBAIAO,MAIK1P,KAAAmF,MACL,WACA8C,EAAA4H,aAAA,WAGA,QAAAA,GAAAzJ,EAAAD,EAAAyJ,GACAzK,KAAAiB,WACA,MAAAD,IACAA,MAEAhB,KAAAgK,WAAAtB,KAAAC,UAAA3H,GACAuK,EAAAvL,KAAAyK,GARA,GAAAc,EA0CA,OA/BAb,GAAAzL,UAAAZ,QAAA,SAAAhC,EAAAmM,GAKA,MAJA,OAAAA,IACAA,MAEAA,EAAAnM,SACA2D,KAAA1C,KAAAkL,IAGAkC,EAAAzL,UAAA3B,KAAA,SAAAkL,GACA,MAAAxI,MAAAiB,SAAA3D,MACAgO,QAAA,UACAtB,WAAAhK,KAAAgK,WACAxB,KAAAE,KAAAC,UAAAH,MAIAkC,EAAAzL,UAAAX,YAAA,WACA,MAAA0B,MAAAiB,SAAAI,cAAAyJ,OAAA9K,OAGAuL,EAAA,SAAAC,EAAAC,GACA,GAAA7L,GAAArE,CACA,UAAAkQ,EACA,IAAA7L,IAAA6L,GACAlQ,EAAAkQ,EAAA7L,GACA4L,EAAA5L,GAAArE,CAGA,OAAAiQ,IAGAd,MAIK7P,KAAAmF,MACL,WACA8C,EAAAe,SAAA,WACA,QAAAA,GAAAH,GACA1D,KAAA0D,MACA1D,KAAAqB,cAAA,GAAAyB,GAAAyH,cAAAvK,MACAA,KAAAuF,WAAA,GAAAzC,GAAAsF,WAAApI,MAuBA,MApBA6D,GAAA5E,UAAA3B,KAAA,SAAAkL,GACA,MAAAxI,MAAAuF,WAAAjI,KAAAkL,IAGA3E,EAAA5E,UAAAtB,QAAA,WACA,MAAAqC,MAAAuF,WAAA8C,QAGAxE,EAAA5E,UAAAf,WAAA,WACA,MAAA8B,MAAAuF,WAAAwD,OACAE,gBAAA,KAIApF,EAAA5E,UAAA2L,uBAAA,WACA,IAAA5K,KAAAuF,WAAAqD,WACA,MAAA5I,MAAAuF,WAAA8C,QAIAxE,MAIKhJ,KAAAmF,QACFnF,KAAAmF,MAEH,gBAAA3F,MAAAC,QACAD,EAAAC,QAAAwI,GAEAH,EAAA,EAAAC,EAAA,kBAAAD,KAAA9H,KAAAP,EAAAE,EAAAF,EAAAD,GAAAsI,IAAAzC,SAAA0C,IAAAvI,EAAAC,QAAAsI,OAEC/H,KAAAmF","file":"redux-cablecar.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _middleware = __webpack_require__(1);\n\t\n\tvar _middleware2 = _interopRequireDefault(_middleware);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _middleware2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _cableCar = __webpack_require__(2);\n\t\n\tvar _cableCar2 = _interopRequireDefault(_cableCar);\n\t\n\tvar _cableCarDispatcher = __webpack_require__(3);\n\t\n\tvar _cableCarDispatcher2 = _interopRequireDefault(_cableCarDispatcher);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar cableProvider = void 0;\n\t\n\tvar dispatcher = new _cableCarDispatcher2.default();\n\t\n\tvar middleware = function middleware(store) {\n\t  return function (next) {\n\t    return function (incomingAction) {\n\t      var action = incomingAction;\n\t      var car = void 0;\n\t\n\t      switch (action.type) {\n\t\n\t        case 'CABLECAR_INITIALIZED':\n\t        case 'CABLECAR_CONNECTED':\n\t        case 'CABLECAR_DISCONNECTED':\n\t          return next(action);\n\t\n\t        case 'CABLECAR_DESTROY':\n\t          dispatcher.destroyCar(action.CableCarChannel);\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_DESTROY_ALL':\n\t          dispatcher.reset();\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_CHANGE_CHANNEL':\n\t          dispatcher.changeCar(action.previousChannel, action.newChannel, action.options);\n\t          return store.getState();\n\t\n\t        default:\n\t          car = action.channel ? dispatcher.getCar(action.channel) : dispatcher.getDefaultCar();\n\t          if (car && car.allows(action) && !action.CableCar__Action) {\n\t            if (car.running) {\n\t              car.send(action);\n\t            } else {\n\t              console.error('CableCar: Dropped action!', 'Attempting to dispatch an action but cable car is not running.', action, 'optimisticOnFail: ' + car.options.optimisticOnFail);\n\t              return car.options.optimisticOnFail ? next(action) : store.getState();\n\t            }\n\t            return action.optimistic ? next(action) : store.getState();\n\t          } else {\n\t            return next(action);\n\t          }\n\t      }\n\t    };\n\t  };\n\t};\n\t\n\tmiddleware.connect = function (store, channel, options) {\n\t  if (!cableProvider) {\n\t    try {\n\t      cableProvider = __webpack_require__(4);\n\t    } catch (e) {\n\t      throw new Error('CableCar: No actionCableProvider set and \\'actioncable\\' Node package failed to load: ' + e);\n\t    }\n\t  }\n\t\n\t  var car = new _cableCar2.default(cableProvider, store, channel, options);\n\t  dispatcher.addCar(channel, car);\n\t\n\t  // public car object returned\n\t  return {\n\t    changeChannel: car.changeChannel.bind(car),\n\t    disconnect: car.disconnect.bind(car),\n\t    getChannel: car.getChannel.bind(car),\n\t    getParams: car.getParams.bind(car),\n\t    perform: car.perform.bind(car),\n\t    send: car.send.bind(car),\n\t    unsubscribe: car.unsubscribe.bind(car)\n\t  };\n\t};\n\t\n\tmiddleware.setProvider = function (newProvider) {\n\t  cableProvider = newProvider;\n\t};\n\t\n\texports.default = middleware;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCar = function () {\n\t  function CableCar(cableProvider, store, channel) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t    _classCallCheck(this, CableCar);\n\t\n\t    this.initialized = function () {\n\t      return _this.dispatch({ type: 'CABLECAR_INITIALIZED' });\n\t    };\n\t\n\t    this.connected = function () {\n\t      _this.dispatch({ type: 'CABLECAR_CONNECTED' });\n\t      _this.running = true;\n\t      if (_this.options.connected) {\n\t        _this.options.connected.call();\n\t      }\n\t    };\n\t\n\t    this.disconnected = function () {\n\t      _this.dispatch({ type: 'CABLECAR_DISCONNECTED' });\n\t      _this.running = false;\n\t      if (_this.options.disconnected) {\n\t        _this.options.disconnected.call();\n\t      }\n\t    };\n\t\n\t    this.received = function (msg) {\n\t      _this.dispatch(msg);\n\t    };\n\t\n\t    this.rejected = function () {\n\t      throw new Error('CableCar: Attempt to connect was rejected.\\n      (Channel: ' + _this.channel + ')');\n\t    };\n\t\n\t    if (typeof cableProvider === 'undefined') {\n\t      throw new Error('CableCar: unknown ActionCable provider: ' + cableProvider);\n\t    }\n\t\n\t    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n\t      throw new Error('CableCar: unknown store: ' + store);\n\t    }\n\t\n\t    if (typeof channel !== 'string') {\n\t      throw new Error('CableCar: unknown channel: ' + channel);\n\t    }\n\t\n\t    this.actionCableProvider = cableProvider;\n\t    this.store = store;\n\t\n\t    var defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n\t    this.initialize(channel, Object.assign(defaultOptions, options));\n\t  }\n\t\n\t  _createClass(CableCar, [{\n\t    key: 'initialize',\n\t    value: function initialize(channel, options) {\n\t\n\t      this.channel = channel;\n\t      this.options = options;\n\t      this.running = false;\n\t\n\t      var cableParams = options.params || {};\n\t      cableParams = Object.assign({ channel: channel }, cableParams);\n\t\n\t      this.consumer = this.actionCableProvider.createConsumer(options.wsURL);\n\t      this.subscription = this.consumer.subscriptions.create(cableParams, {\n\t        initialized: this.initialized,\n\t        connected: this.connected,\n\t        disconnected: this.disconnected,\n\t        received: this.received,\n\t        rejected: this.rejected\n\t      });\n\t    }\n\t\n\t    // ActionCable callback functions\n\t\n\t  }, {\n\t    key: 'dispatch',\n\t\n\t\n\t    // Redux dispatch function\n\t    value: function dispatch(action) {\n\t      var newAction = Object.assign(action, {\n\t        channel: this.channel,\n\t        CableCar__Action: true\n\t      });\n\t      this.store.dispatch(newAction);\n\t    }\n\t  }, {\n\t    key: 'allows',\n\t    value: function allows(action) {\n\t      if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) !== 'object' || typeof action.type !== 'string') {\n\t        throw new Error('CableCar: ' + action + ' is not a valid redux action ({ type: ... })');\n\t      }\n\t\n\t      return this.matchPrefix(action.type);\n\t    }\n\t  }, {\n\t    key: 'matchPrefix',\n\t    value: function matchPrefix(type) {\n\t      var prefix = type.slice(0, this.options.prefix.length);\n\t      return prefix === this.options.prefix;\n\t    }\n\t\n\t    // ActionCable consumer functions (exposed globally)\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.consumer.disconnect();\n\t    }\n\t\n\t    // ActionCable subscription functions (exposed globally)\n\t\n\t  }, {\n\t    key: 'changeChannel',\n\t    value: function changeChannel(channel) {\n\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      this.unsubscribe();\n\t      this.initialize(channel, Object.assign(this.options, options));\n\t    }\n\t  }, {\n\t    key: 'getChannel',\n\t    value: function getChannel() {\n\t      return this.channel;\n\t    }\n\t  }, {\n\t    key: 'getParams',\n\t    value: function getParams() {\n\t      return this.options.params;\n\t    }\n\t  }, {\n\t    key: 'perform',\n\t    value: function perform(method, payload) {\n\t      this.subscription.perform(method, payload);\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(action) {\n\t      this.subscription.send(action);\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {\n\t      this.subscription.unsubscribe();\n\t      this.disconnected();\n\t    }\n\t  }]);\n\t\n\t  return CableCar;\n\t}();\n\t\n\texports.default = CableCar;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCarDispatcher = function () {\n\t  function CableCarDispatcher(provider) {\n\t    _classCallCheck(this, CableCarDispatcher);\n\t\n\t    var lines = {};\n\t\n\t    this.addLine = function (line, car) {\n\t      lines[line] = car;\n\t    };\n\t    this.clearAllLines = function () {\n\t      lines = {};\n\t    };\n\t    this.clearLine = function (line) {\n\t      lines[line] = undefined;\n\t    };\n\t    this.getLines = function () {\n\t      return lines;\n\t    };\n\t  }\n\t\n\t  _createClass(CableCarDispatcher, [{\n\t    key: 'addCar',\n\t    value: function addCar(line, car) {\n\t      if (this.getCar(line)) {\n\t        throw new ReferenceError('CableCar Dispatcher: cannot connect two cars to same line/channel: ' + line);\n\t      }\n\t      this.addLine(line, car);\n\t      return car;\n\t    }\n\t  }, {\n\t    key: 'changeCar',\n\t    value: function changeCar(oldLine, newLine, options) {\n\t      var car = this.getCar(oldLine);\n\t\n\t      if (!car) {\n\t        console.error(new ReferenceError('CableCar Dispatcher (change failed): no car found on line/channel: ' + oldLine));\n\t        return false;\n\t      }\n\t\n\t      if (car.changeChannel) {\n\t        car.changeChannel(newLine, options);\n\t        this.clearLine(oldLine);\n\t        this.addLine(newLine, car);\n\t        return car;\n\t      } else {\n\t        console.error(new ReferenceError('CableCar Dispatcher (change failed): car has no changeChannel function'), car);\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'destroyCar',\n\t    value: function destroyCar(line) {\n\t      var activeLine = line || this.getSingleActiveLine();\n\t\n\t      if (!activeLine) {\n\t        console.error(new ReferenceError('CableCar Dispatcher (destroy failed): No car found on line/channel: ' + line));\n\t        return false;\n\t      }\n\t\n\t      var car = this.getCar(activeLine);\n\t      if (car && car.unsubscribe) {\n\t        car.unsubscribe();\n\t        this.clearLine(activeLine);\n\t        return car;\n\t      } else {\n\t        console.error(new ReferenceError('CableCar Dispatcher (destroy failed): car has no unsubscribe function'), car);\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getCar',\n\t    value: function getCar(line) {\n\t      return this.getLines()[line];\n\t    }\n\t  }, {\n\t    key: 'getDefaultCar',\n\t    value: function getDefaultCar() {\n\t      var activeLine = this.getSingleActiveLine();\n\t      return activeLine ? this.getLines()[activeLine] : undefined;\n\t    }\n\t  }, {\n\t    key: 'getSingleActiveLine',\n\t    value: function getSingleActiveLine() {\n\t      var allLines = this.getLines();\n\t      var activeLines = [];\n\t      for (var line in allLines) {\n\t        if (allLines[line]) {\n\t          activeLines.push(line);\n\t        }\n\t      }\n\t      return activeLines.length === 1 ? activeLines[0] : undefined;\n\t    }\n\t  }, {\n\t    key: 'reset',\n\t    value: function reset() {\n\t      this.clearAllLines();\n\t    }\n\t  }]);\n\t\n\t  return CableCarDispatcher;\n\t}();\n\t\n\texports.default = CableCarDispatcher;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t  var context = this;\n\t\n\t  (function() {\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      this.ActionCable = {\n\t        INTERNAL: {\n\t          \"message_types\": {\n\t            \"welcome\": \"welcome\",\n\t            \"ping\": \"ping\",\n\t            \"confirmation\": \"confirm_subscription\",\n\t            \"rejection\": \"reject_subscription\"\n\t          },\n\t          \"default_mount_path\": \"/cable\",\n\t          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n\t        },\n\t        WebSocket: window.WebSocket,\n\t        logger: window.console,\n\t        createConsumer: function(url) {\n\t          var ref;\n\t          if (url == null) {\n\t            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n\t          }\n\t          return new ActionCable.Consumer(this.createWebSocketURL(url));\n\t        },\n\t        getConfig: function(name) {\n\t          var element;\n\t          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n\t          return element != null ? element.getAttribute(\"content\") : void 0;\n\t        },\n\t        createWebSocketURL: function(url) {\n\t          var a;\n\t          if (url && !/^wss?:/i.test(url)) {\n\t            a = document.createElement(\"a\");\n\t            a.href = url;\n\t            a.href = a.href;\n\t            a.protocol = a.protocol.replace(\"http\", \"ws\");\n\t            return a.href;\n\t          } else {\n\t            return url;\n\t          }\n\t        },\n\t        startDebugging: function() {\n\t          return this.debugging = true;\n\t        },\n\t        stopDebugging: function() {\n\t          return this.debugging = null;\n\t        },\n\t        log: function() {\n\t          var messages, ref;\n\t          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          if (this.debugging) {\n\t            messages.push(Date.now());\n\t            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n\t          }\n\t        }\n\t      };\n\t\n\t    }).call(this);\n\t  }).call(context);\n\t\n\t  var ActionCable = context.ActionCable;\n\t\n\t  (function() {\n\t    (function() {\n\t      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t      ActionCable.ConnectionMonitor = (function() {\n\t        var clamp, now, secondsSince;\n\t\n\t        ConnectionMonitor.pollInterval = {\n\t          min: 3,\n\t          max: 30\n\t        };\n\t\n\t        ConnectionMonitor.staleThreshold = 6;\n\t\n\t        function ConnectionMonitor(connection) {\n\t          this.connection = connection;\n\t          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n\t          this.reconnectAttempts = 0;\n\t        }\n\t\n\t        ConnectionMonitor.prototype.start = function() {\n\t          if (!this.isRunning()) {\n\t            this.startedAt = now();\n\t            delete this.stoppedAt;\n\t            this.startPolling();\n\t            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stop = function() {\n\t          if (this.isRunning()) {\n\t            this.stoppedAt = now();\n\t            this.stopPolling();\n\t            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor stopped\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.isRunning = function() {\n\t          return (this.startedAt != null) && (this.stoppedAt == null);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordPing = function() {\n\t          return this.pingedAt = now();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordConnect = function() {\n\t          this.reconnectAttempts = 0;\n\t          this.recordPing();\n\t          delete this.disconnectedAt;\n\t          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordDisconnect = function() {\n\t          this.disconnectedAt = now();\n\t          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.startPolling = function() {\n\t          this.stopPolling();\n\t          return this.poll();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stopPolling = function() {\n\t          return clearTimeout(this.pollTimeout);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.poll = function() {\n\t          return this.pollTimeout = setTimeout((function(_this) {\n\t            return function() {\n\t              _this.reconnectIfStale();\n\t              return _this.poll();\n\t            };\n\t          })(this), this.getPollInterval());\n\t        };\n\t\n\t        ConnectionMonitor.prototype.getPollInterval = function() {\n\t          var interval, max, min, ref;\n\t          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n\t          interval = 5 * Math.log(this.reconnectAttempts + 1);\n\t          return Math.round(clamp(interval, min, max) * 1000);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.reconnectIfStale = function() {\n\t          if (this.connectionIsStale()) {\n\t            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n\t            this.reconnectAttempts++;\n\t            if (this.disconnectedRecently()) {\n\t              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n\t            } else {\n\t              ActionCable.log(\"ConnectionMonitor reopening\");\n\t              return this.connection.reopen();\n\t            }\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.connectionIsStale = function() {\n\t          var ref;\n\t          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.disconnectedRecently = function() {\n\t          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.visibilityDidChange = function() {\n\t          if (document.visibilityState === \"visible\") {\n\t            return setTimeout((function(_this) {\n\t              return function() {\n\t                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n\t                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n\t                  return _this.connection.reopen();\n\t                }\n\t              };\n\t            })(this), 200);\n\t          }\n\t        };\n\t\n\t        now = function() {\n\t          return new Date().getTime();\n\t        };\n\t\n\t        secondsSince = function(time) {\n\t          return (now() - time) / 1000;\n\t        };\n\t\n\t        clamp = function(number, min, max) {\n\t          return Math.max(min, Math.min(max, number));\n\t        };\n\t\n\t        return ConnectionMonitor;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n\t        slice = [].slice,\n\t        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\t\n\t      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\t\n\t      ActionCable.Connection = (function() {\n\t        Connection.reopenDelay = 500;\n\t\n\t        function Connection(consumer) {\n\t          this.consumer = consumer;\n\t          this.open = bind(this.open, this);\n\t          this.subscriptions = this.consumer.subscriptions;\n\t          this.monitor = new ActionCable.ConnectionMonitor(this);\n\t          this.disconnected = true;\n\t        }\n\t\n\t        Connection.prototype.send = function(data) {\n\t          if (this.isOpen()) {\n\t            this.webSocket.send(JSON.stringify(data));\n\t            return true;\n\t          } else {\n\t            return false;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.open = function() {\n\t          if (this.isActive()) {\n\t            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n\t            return false;\n\t          } else {\n\t            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n\t            if (this.webSocket != null) {\n\t              this.uninstallEventHandlers();\n\t            }\n\t            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n\t            this.installEventHandlers();\n\t            this.monitor.start();\n\t            return true;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.close = function(arg) {\n\t          var allowReconnect, ref1;\n\t          allowReconnect = (arg != null ? arg : {\n\t            allowReconnect: true\n\t          }).allowReconnect;\n\t          if (!allowReconnect) {\n\t            this.monitor.stop();\n\t          }\n\t          if (this.isActive()) {\n\t            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.reopen = function() {\n\t          var error;\n\t          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n\t          if (this.isActive()) {\n\t            try {\n\t              return this.close();\n\t            } catch (error1) {\n\t              error = error1;\n\t              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n\t            } finally {\n\t              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n\t              setTimeout(this.open, this.constructor.reopenDelay);\n\t            }\n\t          } else {\n\t            return this.open();\n\t          }\n\t        };\n\t\n\t        Connection.prototype.getProtocol = function() {\n\t          var ref1;\n\t          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n\t        };\n\t\n\t        Connection.prototype.isOpen = function() {\n\t          return this.isState(\"open\");\n\t        };\n\t\n\t        Connection.prototype.isActive = function() {\n\t          return this.isState(\"open\", \"connecting\");\n\t        };\n\t\n\t        Connection.prototype.isProtocolSupported = function() {\n\t          var ref1;\n\t          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.isState = function() {\n\t          var ref1, states;\n\t          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.getState = function() {\n\t          var ref1, state, value;\n\t          for (state in WebSocket) {\n\t            value = WebSocket[state];\n\t            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n\t              return state.toLowerCase();\n\t            }\n\t          }\n\t          return null;\n\t        };\n\t\n\t        Connection.prototype.installEventHandlers = function() {\n\t          var eventName, handler;\n\t          for (eventName in this.events) {\n\t            handler = this.events[eventName].bind(this);\n\t            this.webSocket[\"on\" + eventName] = handler;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.uninstallEventHandlers = function() {\n\t          var eventName;\n\t          for (eventName in this.events) {\n\t            this.webSocket[\"on\" + eventName] = function() {};\n\t          }\n\t        };\n\t\n\t        Connection.prototype.events = {\n\t          message: function(event) {\n\t            var identifier, message, ref1, type;\n\t            if (!this.isProtocolSupported()) {\n\t              return;\n\t            }\n\t            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n\t            switch (type) {\n\t              case message_types.welcome:\n\t                this.monitor.recordConnect();\n\t                return this.subscriptions.reload();\n\t              case message_types.ping:\n\t                return this.monitor.recordPing();\n\t              case message_types.confirmation:\n\t                return this.subscriptions.notify(identifier, \"connected\");\n\t              case message_types.rejection:\n\t                return this.subscriptions.reject(identifier);\n\t              default:\n\t                return this.subscriptions.notify(identifier, \"received\", message);\n\t            }\n\t          },\n\t          open: function() {\n\t            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n\t            this.disconnected = false;\n\t            if (!this.isProtocolSupported()) {\n\t              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n\t              return this.close({\n\t                allowReconnect: false\n\t              });\n\t            }\n\t          },\n\t          close: function(event) {\n\t            ActionCable.log(\"WebSocket onclose event\");\n\t            if (this.disconnected) {\n\t              return;\n\t            }\n\t            this.disconnected = true;\n\t            this.monitor.recordDisconnect();\n\t            return this.subscriptions.notifyAll(\"disconnected\", {\n\t              willAttemptReconnect: this.monitor.isRunning()\n\t            });\n\t          },\n\t          error: function() {\n\t            return ActionCable.log(\"WebSocket onerror event\");\n\t          }\n\t        };\n\t\n\t        return Connection;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      ActionCable.Subscriptions = (function() {\n\t        function Subscriptions(consumer) {\n\t          this.consumer = consumer;\n\t          this.subscriptions = [];\n\t        }\n\t\n\t        Subscriptions.prototype.create = function(channelName, mixin) {\n\t          var channel, params, subscription;\n\t          channel = channelName;\n\t          params = typeof channel === \"object\" ? channel : {\n\t            channel: channel\n\t          };\n\t          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n\t          return this.add(subscription);\n\t        };\n\t\n\t        Subscriptions.prototype.add = function(subscription) {\n\t          this.subscriptions.push(subscription);\n\t          this.consumer.ensureActiveConnection();\n\t          this.notify(subscription, \"initialized\");\n\t          this.sendCommand(subscription, \"subscribe\");\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.remove = function(subscription) {\n\t          this.forget(subscription);\n\t          if (!this.findAll(subscription.identifier).length) {\n\t            this.sendCommand(subscription, \"unsubscribe\");\n\t          }\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.reject = function(identifier) {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.findAll(identifier);\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            this.forget(subscription);\n\t            this.notify(subscription, \"rejected\");\n\t            results.push(subscription);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.forget = function(subscription) {\n\t          var s;\n\t          this.subscriptions = (function() {\n\t            var i, len, ref, results;\n\t            ref = this.subscriptions;\n\t            results = [];\n\t            for (i = 0, len = ref.length; i < len; i++) {\n\t              s = ref[i];\n\t              if (s !== subscription) {\n\t                results.push(s);\n\t              }\n\t            }\n\t            return results;\n\t          }).call(this);\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.findAll = function(identifier) {\n\t          var i, len, ref, results, s;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            s = ref[i];\n\t            if (s.identifier === identifier) {\n\t              results.push(s);\n\t            }\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.reload = function() {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.sendCommand(subscription, \"subscribe\"));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notifyAll = function() {\n\t          var args, callbackName, i, len, ref, results, subscription;\n\t          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notify = function() {\n\t          var args, callbackName, i, len, results, subscription, subscriptions;\n\t          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\t          if (typeof subscription === \"string\") {\n\t            subscriptions = this.findAll(subscription);\n\t          } else {\n\t            subscriptions = [subscription];\n\t          }\n\t          results = [];\n\t          for (i = 0, len = subscriptions.length; i < len; i++) {\n\t            subscription = subscriptions[i];\n\t            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.sendCommand = function(subscription, command) {\n\t          var identifier;\n\t          identifier = subscription.identifier;\n\t          return this.consumer.send({\n\t            command: command,\n\t            identifier: identifier\n\t          });\n\t        };\n\t\n\t        return Subscriptions;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Subscription = (function() {\n\t        var extend;\n\t\n\t        function Subscription(consumer, params, mixin) {\n\t          this.consumer = consumer;\n\t          if (params == null) {\n\t            params = {};\n\t          }\n\t          this.identifier = JSON.stringify(params);\n\t          extend(this, mixin);\n\t        }\n\t\n\t        Subscription.prototype.perform = function(action, data) {\n\t          if (data == null) {\n\t            data = {};\n\t          }\n\t          data.action = action;\n\t          return this.send(data);\n\t        };\n\t\n\t        Subscription.prototype.send = function(data) {\n\t          return this.consumer.send({\n\t            command: \"message\",\n\t            identifier: this.identifier,\n\t            data: JSON.stringify(data)\n\t          });\n\t        };\n\t\n\t        Subscription.prototype.unsubscribe = function() {\n\t          return this.consumer.subscriptions.remove(this);\n\t        };\n\t\n\t        extend = function(object, properties) {\n\t          var key, value;\n\t          if (properties != null) {\n\t            for (key in properties) {\n\t              value = properties[key];\n\t              object[key] = value;\n\t            }\n\t          }\n\t          return object;\n\t        };\n\t\n\t        return Subscription;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Consumer = (function() {\n\t        function Consumer(url) {\n\t          this.url = url;\n\t          this.subscriptions = new ActionCable.Subscriptions(this);\n\t          this.connection = new ActionCable.Connection(this);\n\t        }\n\t\n\t        Consumer.prototype.send = function(data) {\n\t          return this.connection.send(data);\n\t        };\n\t\n\t        Consumer.prototype.connect = function() {\n\t          return this.connection.open();\n\t        };\n\t\n\t        Consumer.prototype.disconnect = function() {\n\t          return this.connection.close({\n\t            allowReconnect: false\n\t          });\n\t        };\n\t\n\t        Consumer.prototype.ensureActiveConnection = function() {\n\t          if (!this.connection.isActive()) {\n\t            return this.connection.open();\n\t          }\n\t        };\n\t\n\t        return Consumer;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  if (typeof module === \"object\" && module.exports) {\n\t    module.exports = ActionCable;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// redux-cablecar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 45b4500ef74132202776","import middleware from './src/middleware';\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import CableCar from './cableCar';\nimport CableCarDispatcher from './cableCarDispatcher';\n\nlet cableProvider;\n\nconst dispatcher = new CableCarDispatcher();\n\nconst middleware = store => next => (incomingAction) => {\n  const action = incomingAction;\n  let car;\n\n  switch (action.type) {\n\n    case 'CABLECAR_INITIALIZED':\n    case 'CABLECAR_CONNECTED':\n    case 'CABLECAR_DISCONNECTED':\n      return next(action);\n\n    case 'CABLECAR_DESTROY':\n      dispatcher.destroyCar(action.CableCarChannel);\n      return store.getState();\n\n    case 'CABLECAR_DESTROY_ALL':\n      dispatcher.reset();\n      return store.getState();\n\n    case 'CABLECAR_CHANGE_CHANNEL':\n      dispatcher.changeCar(action.previousChannel, action.newChannel, action.options);\n      return store.getState();\n\n    default:\n      car = action.channel ? dispatcher.getCar(action.channel) : dispatcher.getDefaultCar();\n      if (car && car.allows(action) && !action.CableCar__Action) {\n        if (car.running) {\n          car.send(action);\n        } else {\n          console.error('CableCar: Dropped action!',\n            'Attempting to dispatch an action but cable car is not running.',\n            action,\n            'optimisticOnFail: ' + car.options.optimisticOnFail\n          );\n          return car.options.optimisticOnFail ? next(action) : store.getState();\n        }\n        return action.optimistic ? next(action) : store.getState();\n      } else {\n        return next(action);\n      }\n  }\n};\n\nmiddleware.connect = (store, channel, options) => {\n  if (!cableProvider) {\n    try {\n      cableProvider = require('actioncable');\n    } catch(e) {\n      throw new Error(`CableCar: No actionCableProvider set and 'actioncable' Node package failed to load: ${e}`);\n    }\n  }\n\n  let car = new CableCar(cableProvider, store, channel, options);\n  dispatcher.addCar(channel, car);\n\n  // public car object returned\n  return {\n    changeChannel: car.changeChannel.bind(car),\n    disconnect: car.disconnect.bind(car),\n    getChannel: car.getChannel.bind(car),\n    getParams: car.getParams.bind(car),\n    perform: car.perform.bind(car),\n    send: car.send.bind(car),\n    unsubscribe: car.unsubscribe.bind(car),\n  };\n}\n\nmiddleware.setProvider = (newProvider) => {\n  cableProvider = newProvider;\n}\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","\nexport default class CableCar {\n\n  constructor(cableProvider, store, channel, options = {}) {\n    if (typeof cableProvider === 'undefined') {\n      throw new Error(`CableCar: unknown ActionCable provider: ${cableProvider}`);\n    }\n\n    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n      throw new Error(`CableCar: unknown store: ${store}`);\n    }\n\n    if (typeof channel !== 'string') {\n      throw new Error(`CableCar: unknown channel: ${channel}`);\n    }\n\n    this.actionCableProvider = cableProvider;\n    this.store = store;\n\n    const defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n    this.initialize(channel, Object.assign(defaultOptions, options));\n  }\n\n  initialize(channel, options) {\n\n    this.channel = channel;\n    this.options = options;\n    this.running = false;\n\n    let cableParams = options.params || {};\n    cableParams = Object.assign({ channel }, cableParams);\n\n    this.consumer = this.actionCableProvider.createConsumer(options.wsURL);\n    this.subscription = this.consumer.subscriptions.create(\n      cableParams, {\n        initialized: this.initialized,\n        connected: this.connected,\n        disconnected: this.disconnected,\n        received: this.received,\n        rejected: this.rejected,\n      },\n    );\n  }\n\n  // ActionCable callback functions\n  initialized = () => this.dispatch({ type: 'CABLECAR_INITIALIZED' });\n\n  connected = () => {\n    this.dispatch({ type: 'CABLECAR_CONNECTED' });\n    this.running = true;\n    if (this.options.connected) { this.options.connected.call(); }\n  }\n\n  disconnected = () => {\n    this.dispatch({ type: 'CABLECAR_DISCONNECTED' });\n    this.running = false;\n    if (this.options.disconnected) { this.options.disconnected.call(); }\n  }\n\n  received = (msg) => {\n    this.dispatch(msg);\n  }\n\n  rejected = () => {\n    throw new Error(\n      `CableCar: Attempt to connect was rejected.\n      (Channel: ${this.channel})`,\n    );\n  }\n\n  // Redux dispatch function\n  dispatch(action) {\n    const newAction = Object.assign(action, {\n      channel: this.channel,\n      CableCar__Action: true,\n    });\n    this.store.dispatch(newAction);\n  }\n\n  allows(action) {\n    if (typeof action !== 'object' || typeof action.type !== 'string') {\n      throw new Error(`CableCar: ${action} is not a valid redux action ({ type: ... })`);\n    }\n\n    return this.matchPrefix(action.type);\n  }\n\n  matchPrefix(type) {\n    const prefix = type.slice(0, this.options.prefix.length);\n    return prefix === this.options.prefix;\n  }\n\n  // ActionCable consumer functions (exposed globally)\n  disconnect() {\n    this.consumer.disconnect();\n  }\n\n  // ActionCable subscription functions (exposed globally)\n  changeChannel(channel, options = {}) {\n    this.unsubscribe();\n    this.initialize(channel, Object.assign(this.options, options));\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  getParams() {\n    return this.options.params;\n  }\n\n  perform(method, payload) {\n    this.subscription.perform(method, payload);\n  }\n\n  send(action) {\n    this.subscription.send(action);\n  }\n\n  unsubscribe() {\n    this.subscription.unsubscribe();\n    this.disconnected();\n  }\n\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","\nexport default class CableCarDispatcher {\n\n  constructor(provider) {\n    let lines = {};\n\n    this.addLine = (line, car) => { lines[line] = car; }\n    this.clearAllLines = () => { lines = {}; }\n    this.clearLine = (line) => { lines[line] = undefined; }\n    this.getLines = () => lines;\n  }\n\n  addCar(line, car) {\n    if (this.getCar(line)) {\n      throw(new ReferenceError(\n        'CableCar Dispatcher: cannot connect two cars to same line/channel: ' + line\n      ));\n    }\n    this.addLine(line, car);\n    return car;\n  }\n\n  changeCar(oldLine, newLine, options) {\n    let car = this.getCar(oldLine);\n\n    if (!car) {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (change failed): no car found on line/channel: ' + oldLine\n      ));\n      return false;\n    }\n\n    if (car.changeChannel) {\n      car.changeChannel(newLine, options);\n      this.clearLine(oldLine);\n      this.addLine(newLine, car);\n      return car;\n    } else {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (change failed): car has no changeChannel function'\n      ), car);\n      return false;\n    }\n  }\n\n  destroyCar(line) {\n    let activeLine = line || this.getSingleActiveLine();\n\n    if (!activeLine) {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (destroy failed): No car found on line/channel: ' + line\n      ))\n      return false;\n    }\n\n    let car = this.getCar(activeLine);\n    if (car && car.unsubscribe) {\n      car.unsubscribe();\n      this.clearLine(activeLine);\n      return car;\n    } else {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (destroy failed): car has no unsubscribe function'\n      ), car);\n      return false;\n    }\n  }\n\n  getCar(line) {\n    return this.getLines()[line];\n  }\n\n  getDefaultCar() {\n    let activeLine = this.getSingleActiveLine();\n    return activeLine ? this.getLines()[activeLine] : undefined;\n  }\n\n  getSingleActiveLine() {\n    const allLines = this.getLines();\n    let activeLines = [];\n    for (let line in allLines) {\n      if (allLines[line]) { activeLines.push(line); }\n    }\n    return activeLines.length === 1 ? activeLines[0] : undefined;\n  }\n\n  reset() {\n    this.clearAllLines();\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCarDispatcher.js","(function() {\n  var context = this;\n\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(context);\n\n  var ActionCable = context.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}